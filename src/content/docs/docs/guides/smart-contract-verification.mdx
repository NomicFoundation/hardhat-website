---
title: Verifying smart contracts
description: How to verify a smart contract
sidebar:
  label: Verifying contracts
  order: 4
---

import Install from "@hh/Install.astro";
import Run from "@hh/Run.astro";

Smart contract verification is used to prove that a deployed contract's bytecode comes from a specific source code. This allows users and tools to inspect the original source on block explorers, like Etherscan and Blockscout.

In this guide, you'll learn how to verify your contracts using the `hardhat-verify` plugin.

## Setup

If you initialized your project using `hardhat --init`, you don’t need to do anything: `hardhat-verify` is already included as part of the template project.

If you want to add the plugin manually:

1. Install the plugin:

   <Install packages="@nomicfoundation/hardhat-verify" />

2. Add it to the list of plugins in your Hardhat configuration:

   ```ts
   // hardhat.config.ts
   import { defineConfig } from "hardhat/config";
   import hardhatVerify from "@nomicfoundation/hardhat-verify";

   export default defineConfig({
     plugins: [
       hardhatVerify,
       // ...other plugins...
     ],
     // ...other config...
   });
   ```

## Configuration

The `hardhat-verify` plugin adds a `verify` object to the Hardhat configuration. With it, you can configure the different block explorers to verify your contracts on.

To verify contracts on Etherscan, you need to set an API key in your Hardhat configuration:

```ts
// hardhat.config.ts
import { defineConfig } from "hardhat/config";

export default defineConfig({
  // ...
  verify: {
    etherscan: {
      apiKey: "YOUR_ETHERSCAN_API_KEY",
    },
  },
});
```

You can get an Etherscan API key by following [this guide](https://docs.etherscan.io/etherscan-v2/getting-an-api-key).

:::tip

In the previous version of the Etherscan API, you needed a different API key for each chain. With Etherscan V2, a single API key works across all networks.

:::

To verify contracts on Blockscout, you don't need to set an API key, nor any config.

You can also disable a block explorer by setting its `enabled` property to `false`. For example, you can disable Blockscout verification like this:

```ts
// hardhat.config.ts
import { defineConfig } from "hardhat/config";

export default defineConfig({
  // ...
  verify: {
    blockscout: {
      enabled: false,
    },
  },
});
```

## Verifying a contract

To verify a contract, run the `verify` task with the contract's address and the network you deployed it to:

<Run command="hardhat verify --network sepolia 0x1234567890..." />

If your contract has constructor arguments, you have to also pass the values that were used during deployment. For example, if the contract received a `string` and a `uint` as constructor parameters:

<Run command='hardhat verify --network sepolia 0x1234567890... "Hello" 1000' />

If the arguments are too complex to pass directly in the shell—for example, an array of numbers—you can define them in a TypeScript or JavaScript file:

```ts
// constructor-args.ts
const constructorArgs = ["Hello", [1000, 2000]];

export default constructorArgs;
```

and then pass it with the `--constructor-args-path` flag:

<Run command="hardhat verify --network sepolia --constructor-args-path constructor-args.ts 0x1234567890..." />

## Using different build profiles

By default, the `verify` task uses the `production` build profile, as this is the recommended build profile to build your contracts before deploying them. If you deploy your contracts with Hardhat Ignition, you automatically use the `production` build profile.

If you want to use a different build profile, you can pass the `--build-profile` flag:

<Run command="hardhat verify --network sepolia --build-profile default 0x1234567890..." />

## Verifying contracts on different block explorers

The plugin currently supports Etherscan and Blockscout. You can use subtasks to verify on each of the block explorers:

<Run command="hardhat verify etherscan ..." />

They have the same interface, but verify on a different block explorer.

Running `verify` without any subtask will verify on both Etherscan and Blockscout.

## Verifying on a block explorer of a different network

If you want to verify a contract on a block explorer of a network that isn't natively supported by the plugin, you can set a chain descriptor in your Hardhat configuration to add support for that network.

Adding a chain descriptor for a network called "ExampleChain", with chain id `123456`, would look like this:

```ts
// hardhat.config.ts
import { defineConfig } from "hardhat/config";

export default defineConfig({
  // ...
  chainDescriptors: {
    // Example chain
    123456: {
      name: "ExampleChain",
      blockExplorers: {
        etherscan: {
          name: "ExampleScan",
          url: "https://example.scan",
          apiUrl: "https://example.scan/api",
        },
        // other explorers...
      },
    },
  },
});
```

## Troubleshooting

Your verification might fail for a variety of reasons. Here are some common issues and how to fix them:

- **Verifying immediately after deploying**. Your contracts may not have been indexed by the block explorer yet, causing the verification to fail. Normally, waiting a minute is enough for it to work.
- **Wrong constructor arguments**. Double-check that your constructor arguments are correct.
- **Using code that is different from the one used for deployment**. If you are trying to verify a contract that you have deployed weeks ago, then chances are that the code has changed in the meantime. Double-check that you are using the correct code.
- **Using a different build profile**. If you are using a different build profile than the one used for deployment, then the bytecode will be different, causing the verification to fail. Try using `--build-profile` with other profiles to verify your contract, beginning with `default`. You may also need to run `hardhat build` with the same build profile to generate the correct artifacts.
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*
  MineableToken

  - ERC20 token that allows addresses to "mine" tokens over time.
  - Each address accrues tokens continuously at a fixed rate: 10,000 tokens per hour.
  - Accrued tokens sit in an internal "withdrawal balance" until the user calls withdraw().
  - withdraw() mints tokens to the caller up to their accrued amount.
  - Owner can set a global maxSupply (0 = unlimited).
  - Uses OpenZeppelin ERC20, Ownable and ReentrancyGuard.

  Notes:
  - Token has 18 decimals.
  - Rate calculation uses integer math. Keep decimals in mind when selecting display amounts.
*/

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract MineableToken is ERC20, Ownable, ReentrancyGuard {
    uint8 private immutable _decimals;
    uint256 public maxSupply; // 0 => unlimited

    // mining parameters:
    // 10000 tokens per hour => per second rate = 10000 / 3600 tokens/sec
    // We'll store rate with token decimals applied
    uint256 public immutable ratePerSecond; // amount (with decimals) accrued per second

    mapping(address => uint256) public lastUpdate;   // timestamp of last accrual update
    mapping(address => uint256) public accrued;      // accrued amount (with decimals) waiting to be withdrawn
    bool public paused;

    event MiningStarted(address indexed user, uint256 timestamp);
    event MiningStopped(address indexed user, uint256 timestamp);
    event Withdrawn(address indexed user, uint256 amount);
    event MaxSupplyUpdated(uint256 newMaxSupply);
    event Paused(bool paused);

    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 initialMaxSupply // set 0 for unlimited
    ) ERC20(name_, symbol_) {
        _decimals = decimals_;
        maxSupply = initialMaxSupply;
        // compute rate per second scaled by decimals
        // ratePerSecond = 10000 * (10 ** decimals) / 3600
        ratePerSecond = (10000 * (10 ** uint256(decimals_))) / 3600;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    /// @notice Start mining for msg.sender (records timestamp). If already mining, does nothing (but accrues).
    function startMining() external {
        _updateAccrual(msg.sender);
        if (lastUpdate[msg.sender] == 0) {
            // mark start (if previously never started)
            lastUpdate[msg.sender] = block.timestamp;
            emit MiningStarted(msg.sender, block.timestamp);
        }
    }

    /// @notice Stop mining: updates accrual and sets lastUpdate to 0 (so no further accrual).
    function stopMining() external {
        _updateAccrual(msg.sender);
        lastUpdate[msg.sender] = 0;
        emit MiningStopped(msg.sender, block.timestamp);
    }

    /// @notice Withdraw accrued tokens to caller's wallet (mints tokens).
    function withdraw() external nonReentrant {
        require(!paused, "contract paused");
        _updateAccrual(msg.sender);

        uint256 amount = accrued[msg.sender];
        require(amount > 0, "nothing to withdraw");

        // Check maxSupply
        if (maxSupply != 0) {
            uint256 supplyAfter = totalSupply() + amount;
            require(supplyAfter <= maxSupply, "would exceed maxSupply");
        }

        // zero out accrued BEFORE mint to avoid reentrancy edgecases
        accrued[msg.sender] = 0;

        _mint(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
    }

    /// @notice View current accrued balance (including accrual since last update)
    function viewAccrued(address user) public view returns (uint256) {
        uint256 last = lastUpdate[user];
        uint256 currentAccrued = accrued[user];
        if (last == 0) {
            // not mining currently
            return currentAccrued;
        }
        uint256 elapsed = block.timestamp - last;
        uint256 newly = elapsed * ratePerSecond;
        return currentAccrued + newly;
    }

    /// @dev Internal: update accrued[user] and lastUpdate timestamp
    function _updateAccrual(address user) internal {
        uint256 last = lastUpdate[user];
        if (last == 0) {
            // not mining (or never started). Initialize lastUpdate if needed.
            lastUpdate[user] = block.timestamp;
            return;
        }
        uint256 elapsed = block.timestamp - last;
        if (elapsed == 0) return;

        uint256 newly = elapsed * ratePerSecond;
        // if maxSupply set, cap accrual so totalSupply + newly + accrued <= maxSupply
        if (maxSupply != 0) {
            uint256 available = 0;
            uint256 currentSupply = totalSupply();
            if (currentSupply < maxSupply) {
                available = maxSupply - currentSupply;
            } else {
                available = 0;
            }
            // cap newly to available
            if (newly > available) {
                newly = available;
            }
        }

        accrued[user] += newly;
        lastUpdate[user] = block.timestamp;
    }

    // owner functions
    function setMaxSupply(uint256 newMax) external onlyOwner {
        maxSupply = newMax;
        emit MaxSupplyUpdated(newMax);
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
        emit Paused(_paused);
    }

    /// @notice emergency mint for owner (use only for admin actions)
    function ownerMint(address to, uint256 amount) external onlyOwner {
        if (maxSupply != 0) {
            require(totalSupply() + amount <= maxSupply, "would exceed maxSupply");
        }
        _mint(to, amount);
    }
}
// scripts/deploy.js
async function main() {
  const [deployer] = await ethers.getSigners();
  console.log("Deploying with", deployer.address);

  const Mineable = await ethers.getContractFactory("MineableToken");
  // Example args: name, symbol, decimals, maxSupply (0 = unlimited)
  const token = await Mineable.deploy("MyMineToken", "MMT", 18, 0);
  await token.deployed();
  console.log("Token deployed to:", token.address);
}
main().catch(e => { console.error(e); process.exit(1); });
